%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// workaround for peg/leg/greg's shady parsing of "{}" even in
// character class literals
#define _OBRACK '{'
#define _CBRACK '}'

#ifdef USE_GC

void *GC_malloc(size_t);
void *GC_calloc(size_t, size_t);
void *GC_realloc(void *, size_t);
void GC_free(void *);

#define YY_ALLOC(N, D)      GC_malloc(N)
#define YY_CALLOC(N, S, D)  GC_malloc((N) * (S))
#define YY_REALLOC(B, N, D) GC_realloc(B, N)
#define YY_FREE             GC_free

#else

#define YY_ALLOC(N, D)      malloc(N)
#define YY_CALLOC(N, S, D)  calloc(N, S)
#define YY_REALLOC(B, N, D) realloc(B, N)
#define YY_FREE             free

#endif

#define tokenPos { core->token[0] = thunk->begin + G->offset; core->token[1] = (thunk->end - thunk->begin); }
#define tokenPosPlusOne { core->token[0] = thunk->begin + G->offset + 1; core->token[1] = (thunk->end - thunk->begin); }
#define rewindWhiteSpace { char *c = G->buf + G->pos - 1; while((G->pos > 0) && ((*c) == ' ' || (*c) == '\t' || (*c) == '\n' || (*c) == '\r')) { c--; G->pos--; } }

#define missingOp(c) { \
    rewindWhiteSpace; \
    char message[2048]; \
    snprintf(message, 2048, "Missing right operand for '%s' operator!\n", (c)); \
    nq_error(core->this, NQE_MISSING_OPERAND, message, G->pos + G->offset); \
}

#define YYSTYPE void*

// the default is 1024, but it causes buffers to be reallocated 4 or 5
// times during the parsing. This is a better default for us, only a few
// modules need to reallocate with that setting
#define YY_BUFFER_START_SIZE 16384
#define YY_STACK_SIZE YY_BUFFER_START_SIZE

//#define YY_DEBUG

///////////////////// main struct, for the sake of being re-entrant ////////////////////////

struct _Core {
    void *this;
    int yylineno;
    char* path;
    FILE *stream;
    int token[2];
    char typeBuffer[4096];
    int importQuantity;
};

typedef struct _Core Core;

#define YY_XTYPE Core *
#define YY_XVAR core

#define YY_INPUT(buf, result, max_size, core) yyInput(buf, &result, max_size, core)

void yyInput(char *buf, int *result, int max_size, Core *core) {
    (*result) = fread(buf, 1, max_size, core->stream);
    static int doneNewlineHack = 0;
    if((*result) == 0 && doneNewlineHack == 0) {
        doneNewlineHack = 1;
        (*buf) = '\n';
        (*result) = 1;
        return;
    }
    for(int i = 0; i < (*result) - 1; i++) {
        if(buf[i] == '\\') {
            if(buf[i+1] == '\r') {
                buf[i] = ' ';
                buf[i+1] = ' ';
                if(buf[i+2] == '\n') {
                    buf[i+2] == ' ';
                    i += 2; continue;
                }
                i += 1; continue;
            } else if(buf[i+1] == '\n') {
                buf[i] = ' ';
                buf[i+1] = ' ';
                i += 1; continue;
            }
        }
    }
}

///////////////////// callbacks def start, you may want to skip this ////////////////////////

void nq_setTokenPositionPointer(void *this, int *tokenPosPointer);

char *nq_StringClone(char *string);
char *nq_trailingQuest(char *string);
char *nq_trailingBang (char *string);

void nq_onUse(void *this, char *name);
void nq_onInclude(void *this, char *path);
void nq_onIncludeDefine(void *this, char *name, char *value);
void nq_onImport (void *this, char *path, char *name);
void nq_onImportNamespace(void *this, char *namespace, int quantity);

void *nq_onVersionName(void *this, char *name);
void *nq_onVersionNegation(void *this, void *spec);
void *nq_onVersionAnd(void *this, void *specLeft, void *specRight);
void *nq_onVersionOr(void *this, void *specLeft, void *specRight);

void nq_onVersionStart(void *this, void *spec);
void *nq_onVersionElseIfStart(void *this, void *notSpec, void *elseSpec);
void nq_onVersionElseStart(void *this, void *notSpec);
void *nq_onVersionEnd(void *this);

void nq_onExtendStart(void *this, void *type, char *doc);
void nq_onExtendEnd(void *this);

void nq_onCoverStart(void *this, char *name, char *doc);
void nq_onCoverExtern(void *this, char *externName);
void nq_onCoverFromType(void *this, void *type);
void nq_onCoverExtends(void *this, void *type);
void nq_onCoverImplements(void *this, void *type);
void nq_onCoverEnd(void *this);

void nq_onEnumStart(void *this, char *name, char *doc);
void nq_onEnumExtern(void *this, char *externName);
void nq_onEnumFromType(void *this, void *fromType);
void nq_onEnumIncrementExpr(void *this, char oper, void *step);
void nq_onEnumElementStart(void *this, char *name, char *doc);
void nq_onEnumElementValue(void *this, void *value);
void nq_onEnumElementExtern(void *this, char *externName);
void nq_onEnumElementEnd(void *this);
void nq_onEnumEnd(void *this);

void nq_onClassStart(void *this, char *name, char *doc);
void nq_onClassAbstract(void *this);
void nq_onClassFinal(void *this);
void nq_onClassExtends(void *this, void *type);
void nq_onClassImplements(void *this, void *type);
void nq_onClassBody(void *this);
void nq_onClassEnd(void *this);

void nq_onInterfaceStart(void *this, char *name, char *doc);
void nq_onInterfaceExtends(void *this, void *type);
void nq_onInterfaceEnd(void *this);

void nq_onPropertyDeclStart(void *this, char *name, char *doc);
void nq_onPropertyDeclStatic(void *this);
void nq_onPropertyDeclType(void *this, void *type);
void *nq_onPropertyDeclEnd(void *this);

void nq_onPropertyDeclGetterStart(void *this, char *doc);
void *nq_onPropertyDeclGetterEnd(void *this);

void nq_onPropertyDeclSetterStart(void *this, char *doc);
void nq_onPropertyDeclSetterArgument(void *this, char *name, _Bool conventional);
void *nq_onPropertyDeclSetterEnd(void *this);

void nq_onVarDeclStart(void *this);
void nq_onVarDeclName(void *this, char *name, char *doc);
void nq_onVarDeclTuple(void *this, void *tuple);
void nq_onVarDeclExtern(void *this, char *externName);
void nq_onVarDeclUnmangled(void *this, char *unmangledName);
void nq_onVarDeclExpr(void *this, void *expr);
void nq_onVarDeclType(void *this, void *type);
void nq_onVarDeclStatic(void *this);
void nq_onVarDeclConst(void *this);
void nq_onVarDeclProto(void *this);
void *nq_onVarDeclEnd(void *this);

void *nq_onTypeAccess(void *this, void *type);

void *nq_onTypeNew(void *this, char *name);     // $$=nq_onTypeNew(yytext)
void *nq_onTypePointer(void *this, void *type);   // $$=nq_onTypePointer($$)
void *nq_onTypeReference(void *this, void *type); // $$=nq_onTypeReference($$)
void *nq_onTypeBrackets(void *this, void *type, void *inner); // $$=nq_onTypeBrackets($$, inner)
void nq_onTypeGenericArgument(void *this, void *type, void *genType);
void nq_onFuncTypeGenericArgument(void *this, void *type, char *name);
void *nq_onTypeList(void *this);
void *nq_onTypeListElement(void *this, void *list, void *elem);

void *nq_onFuncTypeNew(void *this);
void nq_onFuncTypeArgument(void *this, void *funcType, void *argType);
void nq_onFuncTypeVarArg(void *this, void *funcType);
void nq_onFuncTypeReturnType(void *this, void *funcType, void *returnType);

void nq_onOperatorStart(void *this, char *symbol);
void nq_onOperatorEnd(void *this);

void nq_onFunctionStart(void *this, char *name, char *doc);
void nq_onFunctionExtern(void *this, char *externName);
void nq_onFunctionUnmangled(void *this, char *unmangledName);
void nq_onFunctionAbstract(void *this);
void nq_onFunctionThisRef(void *this);
void nq_onFunctionArgsStart(void *this);
void nq_onFunctionArgsEnd(void *this);
void nq_onFunctionReturnType(void *this, void *type);
void nq_onFunctionConst(void *this);
void nq_onFunctionStatic(void *this);
void nq_onFunctionInline(void *this);
void nq_onFunctionFinal(void *this);
void nq_onFunctionProto(void *this);
void nq_onFunctionSuper(void *this);
void nq_onFunctionSuffix(void *this, char *name);
void nq_onFunctionBody(void *this);
void *nq_onFunctionEnd(void *this);

void nq_onTypeArg(void *this, void *type);
void nq_onVarArg(void *this, char *name);
void nq_onDotArg(void *this, char *name);
void nq_onAssArg(void *this, char *name);

void nq_onFunctionCallStart(void *this, char *yytext);
void nq_onFunctionCallSuffix(void *this, char *yytext);
void nq_onFunctionCallArg(void *this, void *expr);
void *nq_onFunctionCallEnd(void *this);
void nq_onFunctionCallExpr(void *this, void *call, void *expr);
void *nq_onFunctionCallChain(void *this, void *expr, void *call);
void nq_onFunctionCallCombo(void *this, void *call, void *expr);

void nq_onArrayLiteralStart(void *this);
void *nq_onArrayLiteralEnd(void *this);

void nq_onTupleStart(void *this);
void *nq_onTupleEnd(void *this);

void *nq_onStringLiteral(void *this, char *text);
void *nq_onCharLiteral(void *this, char *value);

void nq_onStatement(void *this, void *statement);
void *nq_onReturn(void *this, void *expr);

void *nq_onVarAccess(void *this, void *expr, char *name);
void nq_onArrayAccessStart(void *this, void *array);
void *nq_onArrayAccessEnd(void *this);
void *nq_onCast(void *this, void *expr, void *type);

void *nq_onBreak(void *this);
void *nq_onContinue(void *this);

void nq_onBlockStart(void *this);
void *nq_onBlockEnd(void *this);

void nq_onIfStart(void *this, void *condition);
void *nq_onIfEnd(void *this);
void nq_onElseStart(void *this);
void *nq_onElseEnd(void *this);

void nq_onForeachStart(void *this, void *decl, void *collec);
void *nq_onForeachEnd(void *this);

void nq_onWhileStart(void *this, void *condition);
void *nq_onWhileEnd(void *this);

void *nq_onEquals(void *this, void *left, void *right);
void *nq_onNotEquals(void *this, void *left, void *right);
void *nq_onLessThan(void *this, void *left, void *right);
void *nq_onMoreThan(void *this, void *left, void *right);
void *nq_onCmp(void *this, void *left, void *right);
void *nq_onLessThanOrEqual(void *this, void *left, void *right);
void *nq_onMoreThanOrEqual(void *this, void *left, void *right);

void *nq_onDecLiteral(void *this, char *value);
void *nq_onBinLiteral(void *this, char *value);
void *nq_onOctLiteral(void *this, char *value);
void *nq_onHexLiteral(void *this, char *value);
void *nq_onFloatLiteral(void *this, char *value);
void *nq_onBoolLiteral(void *this, bool value);
void *nq_onNull(void *this);

void *nq_onTernary(void *this, void *condition, void *ifTrue, void *ifFalse);
void *nq_onAssignAnd(void *this, void *left, void *right);
void *nq_onAssignOr(void *this, void *left, void *right);
void *nq_onAssignXor(void *this, void *left, void *right);
void *nq_onAssignRightShift(void *this, void *left, void *right);
void *nq_onAssignLeftShift(void *this, void *left, void *right);
void *nq_onAssignDiv(void *this, void *left, void *right);
void *nq_onAssignMul(void *this, void *left, void *right);
void *nq_onAssignExp(void *this, void *left, void *right);
void *nq_onAssignSub(void *this, void *left, void *right);
void *nq_onAssignAdd(void *this, void *left, void *right);
void *nq_onAssign(void *this, void *left, void *right);

void *nq_onAdd(void *this, void *left, void *right);
void *nq_onSub(void *this, void *left, void *right);
void *nq_onMod(void *this, void *left, void *right);
void *nq_onMul(void *this, void *left, void *right);
void *nq_onExp(void *this, void *left, void *right);
void *nq_onDiv(void *this, void *left, void *right);
void *nq_onRangeLiteral(void *this, void *left, void *right);
void *nq_onBinaryLeftShift(void *this, void *left, void *right);
void *nq_onBinaryRightShift(void *this, void *left, void *right);
void *nq_onLogicalOr(void *this, void *left, void *right);
void *nq_onLogicalAnd(void *this, void *left, void *right);
void *nq_onBinaryOr(void *this, void *left, void *right);
void *nq_onBinaryXor(void *this, void *left, void *right);
void *nq_onBinaryAnd(void *this, void *left, void *right);

void *nq_onLogicalNot(void *this, void *inner);
void *nq_onBinaryNot(void *this, void *inner);
void *nq_onUnaryMinus(void *this, void *inner);

void *nq_onParenthesis(void *this, void *inner);

void nq_onGenericArgument(void *this, char *name);

void *nq_onAddressOf  (void *this, void *inner);
void *nq_onDereference(void *this, void *inner);

void nq_onMatchStart(void *this);
void nq_onMatchExpr(void *this, void *value);
void *nq_onMatchEnd(void *this);
void nq_onCaseStart(void *this);
void nq_onCaseExpr(void *this, void *value);
void nq_onCaseEnd(void *this);

void nq_onTryStart(void *this);
void *nq_onTryEnd(void *this);
void nq_onCatchStart(void *this);
void nq_onCatchExpr(void *this, void *value);
void nq_onCatchEnd(void *this);

void nq_error(void *this, int errorID, char *defaultMessage, int index);

/////////////////////                callbacks def end               ////////////////////////

/////////////////////                 error IDs start                ////////////////////////

// NQE stands for 'NagaQueen Error"

enum NagaQueenError {
    NQE_EXP_STATEMENT_OR_CLOSING_BRACKET = 1,
    NQE_EXP_INC_IMP_STMT_OR_DECL,
    NQE_EXP_CASE_IN_MATCH,
    NQE_EXP_VAR_OR_FUNC_DECL,
    NQE_EXP_RET_TYPE,
    NQE_EXP_CLOSING_PAREN,
    NQE_EXP_CLOSING_SQUAR,
    NQE_EXP_ARG,
    NQE_UNCLOSED_COMMENT,
    NQE_MISSING_OPERAND,
    NQE_MISPLACED_SUFFIX,
    NQE_MALFORMED_STRINGLIT,
    NQE_MALFORMED_CHARLIT,
    NQE_MALFORMED_TERNARY,
};

/////////////////////                  error IDs end                 ////////////////////////

%}

Module  =  ModuleCore
          | WS ( !EOL . )*
          EOL { tokenPos; char *message = "Expected include, import, statement or declaration\n";
            if(G->buf[core->token[0]] == _CBRACK) { message = "Unmatched closing bracket"; }
            nq_error(core->this, NQE_EXP_INC_IMP_STMT_OR_DECL, message, core->token[0]);
          }

ModuleCore = 
          ( WS Import WS
          | WS Use WS
          | WS Decl WS
          | WS stmt:Stmt WS { nq_onStatement(core->this, stmt) }
          )

Use = USE_KW [ \t]
      - UseCore
      (
      - ','
      - UseCore
      )*

UseCore = < ([A-Za-z0-9/._] | '-')+ > { tokenPos; nq_onUse(core->this, nq_StringClone(yytext)) }

Import  = IMPORT_KW [ \t]
          - ImportAtom
          (
          ',' WS
          - ImportAtom
          )*

ImportAtom = path:ImportPath
            ((name:ImportName { tokenPosPlusOne; }             { nq_onImport(core->this, (char*) path, (char*) name) }
             (- INTO_KW - namespace:IDENT               { nq_onImportNamespace(core->this, (char*) namespace, 1) })?
             ) | (
            '[' { core->importQuantity = 0; }
            (name:ImportName { tokenPosPlusOne; } - ',' WS   { core->importQuantity++; nq_onImport(core->this, (char*) path, (char*) name) })*
            (name:ImportName { tokenPosPlusOne; }              { core->importQuantity++; nq_onImport(core->this, (char*) path, (char*) name) })
            ']'
            ))

ImportPath = < (([A-Za-z_0-9] | "." | "-")+ "/")* > { $$=nq_StringClone(yytext) }
ImportName = < ([A-Za-z_0-9] | "-")+ >                { $$=nq_StringClone(yytext) }


Decl    = ( FunctionDecl
          | StructureDecl
          | vd:VariableDecl Terminator+ { nq_onStatement(core->this, vd) }
          )

FunctionDecl =
            - FUNC_KW
            name:IDENT { tokenPos; nq_onFunctionStart(core->this, name, doc) }

            # modifiers
            (-  ( externName:ExternName  { nq_onFunctionExtern(core->this, externName) }
                | unmangledName:UnmangledName { nq_onFunctionUnmangled(core->this, unmangledName) }
                )
            )*

            FunctionDeclBody
            - END_KW


FunctionDeclBody = (
            # arguments are optional
            (
                (          WS Argument WS
                    (',' WS Argument WS)*
                )?
                              { nq_onFunctionArgsEnd(core->this) }
            )?

            # return type is optional
            (
                - R_ARROW
                - t:Type ~{ nq_error(core->this, NQE_EXP_RET_TYPE, "Missing return type.\n", G->pos + G->offset) }
                          { nq_onFunctionReturnType(core->this, t) }
            )?

            # body is optional (for abstract/extern-named functions)
            (
                { nq_onFunctionBody(core->this); }
                WS EOL
                (WS
                (s:Stmt  { nq_onStatement(core->this, s) })
                WS)*
                WS END_KW ~{ rewindWhiteSpace; nq_error(core->this, NQE_EXP_STATEMENT_OR_CLOSING_BRACKET, "Malformed statement or end keyword missing\n", G->pos + G->offset) }
            )?
            ) { $$=nq_onFunctionEnd(core->this); }

Argument    = ( vd:VariableDecl          { tokenPos; nq_onStatement(core->this, vd) }
              | type:Type                { tokenPos; nq_onTypeArg(core->this, type) }
              | "..."                    { tokenPos; nq_onVarArg(core->this, NULL) } # C varargs
              )

EnumDecl    = (
            doc: OocDoc

            enumName:IDENT { tokenPos; nq_onEnumStart(core->this, enumName, doc); }
            - COLON

            # modifiers (extern)
            (- externName:ExternName { nq_onEnumExtern(core->this, externName); })?

            - ENUM_KW

            # optional from-type
            (- FROM_KW - fromType:Type { tokenPos; nq_onEnumFromType(core->this, fromType); })?

            # increment expression (ex: *2 or +1)
            (
            - '('
            - op:EnumIncrementOper WS step:IntLiteral { nq_onEnumIncrementExpr(core->this, op, step); }
            - ')'
            )?

            (
                WS '{' WS

                # enumeration elements
                (EnumElement
                (
                    (Terminator+ WS FunctionDecl) |
                    ((',' | Terminator+) WS EnumElement)
                )*
                )?

                WS
                CLOS_BRACK ~{ nq_error(core->this, NQE_EXP_VAR_OR_FUNC_DECL, "Expected enum element!\n", G->pos + G->offset); }
            )

            ) { tokenPos; nq_onEnumEnd(core->this) }

EnumElement = (
                doc: OocDoc

                i:IDENT { tokenPos; nq_onEnumElementStart(core->this, i, doc); }
                - ( ASS value:Expr { nq_onEnumElementValue(core->this, value); }
                  | COLON
                    - externName:ExternName { nq_onEnumElementExtern(core->this, externName); }
                  )?
            ) { nq_onEnumElementEnd(core->this) }

EnumIncrementOper =  ( STAR { $$='*'; }
                     | PLUS { $$='+'; }
                     )

ExternName = EXTERN_KW { $$="" }
              (
              - '('
              - < [A-Za-z_] [A-Za-z0-9_]* > { $$=yytext } # is that correct? should it be $$=$$? what's happening?
              - ')'
              )?

UnmangledName = UNMANGLED_KW { $$="" }
             (
             - '('
             - unmangledName:IDENT { $$=unmangledName }
             - ')'
             )?

VariableDecl =
            { nq_onVarDeclStart(core->this); }

            (
            varDeclName:IDENT { tokenPos; nq_onVarDeclName(core->this, varDeclName, doc); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?

            # multi-decls
            (
            - ','
            doc: OocDoc
            WS nextDeclName:IDENT { nq_onVarDeclName(core->this, nextDeclName, doc); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            -
            )*

            WS COLON WS
            (-
              (
                  externName:ExternName { nq_onVarDeclExtern(core->this, externName); }
                | unmangledName:UnmangledName { nq_onVarDeclUnmangled(core->this, unmangledName); }
              )
            )*
            WS Type { nq_onVarDeclType(core->this, $$); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            )  { $$=nq_onVarDeclEnd(core->this); }


TypeBase = FuncType |
          (< { tokenPos; core->typeBuffer[0]='\0'; } (CONST_KW -)?
            (
                ( "unsigned"                                  { strcat(core->typeBuffer, "unsigned "); } -
                | "signed"                                    { strcat(core->typeBuffer, "signed "); } -
                | "long" &(- ("long" | "double" | "int"))     { strcat(core->typeBuffer, "long "); } -
                | "struct"			                          { strcat(core->typeBuffer, "struct "); } -
                | "union"			                          { strcat(core->typeBuffer, "union "); } -
                )
            - )*
            rest:IDENT { strcat(core->typeBuffer, rest); }
          > { $$=nq_onTypeNew(core->this, core->typeBuffer); })

Type    = list:TypeList { $$=list; } | (
          t:TypeBase
          - (STAR { t=$$=nq_onTypePointer  (core->this, t); }
          | "[" WS { inner=NULL; } - inner:Expr? "]" { t=$$=nq_onTypeBrackets(core->this, t, inner); }
          )*
          - { $$=t; })

TypeListCore = { $$=nq_onTypeList(core->this); }
TypeList = '(' WS list:TypeListCore
                      elem:Type { nq_onTypeListElement(core->this, list, elem) }
           (WS ',' WS elem:Type { nq_onTypeListElement(core->this, list, elem) })*
           ')' -
           { $$=list; }

FuncTypeCore = "Συνάρτηση" &[^A-Za-z0-9_] { tokenPos; $$=nq_onFuncTypeNew(core->this); }

FuncType  = funcType:FuncTypeCore
            (
            - '('
            (    - argType:Type { nq_onFuncTypeArgument(core->this, funcType, argType); }
            (',' - argType:Type { nq_onFuncTypeArgument(core->this, funcType, argType); })*
            )?
            ("..." - { nq_onFuncTypeVarArg(core->this, funcType); })?
            - ')'
            )?
            (- '->'
             - returnType:Type { nq_onFuncTypeReturnType(core->this, funcType, returnType); }
            )?
            { $$=funcType; }

Stmt = (
              # some statements need an EOL after them...
              e:EoledStatement
              (Terminator+ | (WS &"Τέλος") | (WS &')') | (WS &',') | (&CommentLine))
           )
          | # ...but block don't
          ( WS c:Conditional
          | WS b:Block
          | WS f:FlowControl (Terminator*)
          )

EoledStatement =  ( WS Return
                  | WS VariableDecl
                  | WS Expr
                  )

Conditional = (If | Else)

Block   = (
           '{' { tokenPos; nq_onBlockStart(core->this); }
          (WS s:Stmt { tokenPos; nq_onStatement(core->this, s) } WS)*
           WS '}' { $$=nq_onBlockEnd(core->this); }
          )

If      = (
          IF_KW { tokenPos; }
          - WS e:Expr WS       { nq_onIfStart(core->this, e); }
          - THEN_KW WS
          - EOL
          - Body
          - END_KW
          )              { $$=nq_onIfEnd(core->this); }

Else    = (
          ELSE_KW  { tokenPos; }
                         { nq_onElseStart(core->this); }
          - WS EOL
          - Body
          )              { $$=nq_onElseEnd(core->this); }

FlowControl = (Foreach | While | Break | Continue)

Break    = BREAK_KW    { tokenPos; $$=nq_onBreak(core->this); }
Continue = CONTINUE_KW { tokenPos; $$=nq_onContinue(core->this); }

ImplicitDecl = (v:VariableDecl { $$=v })
             | (i:IDENT        { $$=nq_onVarAccess(core->this, NULL, i); })

Foreach = FOR_KW { tokenPos; }
          - WS decl:ImplicitDecl WS
          - IN_KW
          - collec:Expr WS { nq_onForeachStart(core->this, decl, collec); }
          - EOL
          - Body
          - END_KW
          -            { $$=nq_onForeachEnd(core->this); }

While = WHILE_KW { tokenPos; }
        - WS condition:Expr WS { nq_onWhileStart(core->this, condition); }
        - EOL
        - Body
        - END_KW
        -            { $$=nq_onWhileEnd(core->this); }

Body =  (
        (WS s:Stmt { tokenPos; nq_onStatement(core->this, s) } WS)*
        ) | s:Stmt { tokenPos; nq_onStatement(core->this, s) }

Return  = (RETURN_KW &([^A-Za-z_]) { tokenPos; } - e:Expr { $$=nq_onReturn(core->this, e); })
        | (RETURN_KW &([^A-Za-z_]) { tokenPos; } -        { $$=nq_onReturn(core->this, NULL); })


Expr     =   v:VariableDecl -
           | b:BinaryOperation

#operators

BinaryOperation = Assignment

Assignment = l: Ternary
                ( ASS            { tokenPos; }  WS   r: Ternary               { $$=l=nq_onAssign(core->this, l, r); }
                # The following line is actually the only case where AnonymousFunctionDecl makes sense at this level of precedence.
                | ASS            { tokenPos; }  WS   r: AnonymousFunctionDecl ~{  missingOp("<-") }   { $$=l=nq_onAssign(core->this, l, r); }
                )*

Ternary =   cond:LogicalOr
            (
          - QUEST { tokenPos; }
          WS ifTrue:LogicalOr ~{ nq_error(core->this, NQE_MALFORMED_TERNARY, "Expected expression between ? and : in ternary expression!\n", G->pos + G->offset) }
          - COLON
          WS ifFalse:LogicalOr
            { $$=nq_onTernary(core->this, cond, ifTrue, ifFalse); }
            )?

LogicalOr = l:LogicalAnd
                ( L_OR        { tokenPos; } WS  r: LogicalAnd         ~{  missingOp("ή") } { $$=l=nq_onLogicalOr(core->this, l, r); }
                )*

LogicalAnd = l:BinaryOr
                ( L_AND       { tokenPos; } WS  r: BinaryOr           ~{  missingOp("και") } { $$=l=nq_onLogicalAnd(core->this, l, r); }
                )*

BinaryOr = l:BinaryXor
                ( B_OR        { tokenPos; } WS  r: BinaryXor           ~{  missingOp("|") } { $$=l=nq_onBinaryOr(core->this, l, r); }
                )*

BinaryXor = l:BinaryAnd
                ( B_XOR       { tokenPos; } WS  r: BinaryAnd           ~{  missingOp("^") } { $$=l=nq_onBinaryXor(core->this, l, r); }
                )*

BinaryAnd = l:Equality
                ( B_AND       { tokenPos; } WS  r: Equality            ~{  missingOp("&") } { $$=l=nq_onBinaryAnd(core->this, l, r); }
                )*

Equality = l:Inequality
                ( EQUALS      { tokenPos; } WS  r:Inequality          ~{  missingOp("=") } { $$=l=nq_onEquals(core->this, l, r); }
                | NOT_EQUALS  { tokenPos; } WS  r:Inequality          ~{  missingOp("<>") } { $$=l=nq_onNotEquals(core->this, l, r); }
                )*

Inequality = l:Range
                ( LESSTHAN    { tokenPos; } WS  r:Range                ~{  missingOp("<") } { $$=l=nq_onLessThan(core->this, l, r); }
                | MORETHAN    { tokenPos; } WS  r:Range                ~{  missingOp(">") } { $$=l=nq_onMoreThan(core->this, l, r); }
                | CMP         { tokenPos; } WS  r:Range              ~{  missingOp("<=>") } { $$=l=nq_onCmp(core->this, l, r); }
                | LESSTHAN_EQ { tokenPos; } WS  r:Range               ~{  missingOp("<=") } { $$=l=nq_onLessThanOrEqual(core->this, l, r); }
                | MORETHAN_EQ { tokenPos; } WS  r:Range               ~{  missingOp(">=") } { $$=l=nq_onMoreThanOrEqual(core->this, l, r); }
                )*

Range   = l:Shift
                ( DOUBLE_DOT  { tokenPos; } WS  r:Shift               ~{  missingOp("..") } { $$=l=nq_onRangeLiteral(core->this, l, r); }
                )*

Shift   = l:Sum
                ( B_LSHIFT    { tokenPos; } WS  r:Sum                 ~{  missingOp("<<") } { $$=l=nq_onBinaryLeftShift(core->this, l, r) }
                | B_RSHIFT    { tokenPos; } WS  r:Sum                 ~{  missingOp(">>") } { $$=l=nq_onBinaryRightShift(core->this, l, r) }
                )*

Sum     = l:Product
                ( PLUS        { tokenPos; } WS  r:Product              ~{  missingOp("+") } { $$=l=nq_onAdd(core->this, l, r); }
                | MINUS       { tokenPos; } WS  r:Product              ~{  missingOp("-") } { $$=l=nq_onSub(core->this, l, r); }
                | PERCENT     { tokenPos; } WS  r:Product              ~{  missingOp("%") } { $$=l=nq_onMod(core->this, l, r); }
                )*

Product = (ProductLogicalNot | ProductBinaryNot | ProductCore)

ProductLogicalNot = L_NOT { tokenPos; } - (inner:Product) - { $$=inner=nq_onLogicalNot(core->this, inner); }
ProductBinaryNot  = B_NOT { tokenPos; } - (inner:Product) - { $$=inner=nq_onBinaryNot (core->this, inner); }

ProductCore = l:Access
                    ( EXP { tokenPos; } WS r:Product { $$=l=nq_onExp(core->this, l, r); }
                    | STAR { tokenPos; } WS r:Access { $$=l=nq_onMul(core->this, l, r); }
                    | SLASH { tokenPos; } WS r:Access { $$=l=nq_onDiv(core->this, l, r); }
                    )*

Access =  ((ident:IDENT_CORE { tokenPos; } '&' ![&=] - { core->token[1] += 1; $$=l=nq_onAddressOf(core->this, nq_onVarAccess(core->this, NULL, ident)); }) # special case: blah& is always a reference. blah & blih is a binary and.
          | l:Value)
                ((
                    - '[' - { tokenPos; nq_onArrayAccessStart(core->this, l); }
                             index:Expr - { nq_onStatement(core->this, index); }
                   (',' WS index:Expr - { nq_onStatement(core->this, index); })*
                    - ']' - { $$=l=nq_onArrayAccessEnd(core->this); }
                 )
                | - call:FunctionCall                   { nq_onFunctionCallExpr(core->this, call, l); $$=l=call; }
                | - r:IDENT_CORE { tokenPos; $$=l=nq_onVarAccess(core->this, l, r); }
                | - AS_KW { tokenPos; } -  r:Type       { $$=l=nq_onCast(core->this, l, r); }
                | '&' ![&=] - &([ \t\r\n;,)}] | ']')    { core->token[1] += 1; $$=l=nq_onAddressOf(core->this, l); }
                | '@'                                    { $$=l=nq_onDereference(core->this, l); }
                | - call:FunctionCallNoname             { nq_onFunctionCallCombo(core->this, call, l); $$=l=call; }
                )* -

FunctionCall = callName:IDENT { tokenPos; nq_onFunctionCallStart(core->this, callName); }
               FunctionCallCore { $$=nq_onFunctionCallEnd(core->this); }

FunctionCallCore = (B_NOT - callSuffix:IDENT { nq_onFunctionCallSuffix(core->this, callSuffix); })?
               '(' WS
	       (
                ( e:Expr { tokenPos; nq_onFunctionCallArg(core->this, e); }
                | a:ACS  { tokenPos; nq_onFunctionCallArg(core->this, a); })
               (WS
               ','
               WS
                ( e:Expr { tokenPos; nq_onFunctionCallArg(core->this, e); }
                | a:ACS  { tokenPos; nq_onFunctionCallArg(core->this, a); })
               )*
               )?
               WS CLOS_PAREN ~{ rewindWhiteSpace; nq_error(core->this, NQE_EXP_CLOSING_PAREN, "Expected closing parenthesis to finish the function call!\n", G->pos + G->offset) }

FunctionCallNoname = { tokenPos; nq_onFunctionCallStart(core->this, ""); }
               FunctionCallCore { $$=nq_onFunctionCallEnd(core->this); }

ACS = (
        { tokenPos; nq_onFunctionStart(core->this, "", ""); nq_onFunctionArgsStart(core->this); }
        '|' WS?
        ( i:IDENT { tokenPos; nq_onVarDeclStart(core->this); nq_onVarDeclName(core->this, i, ""); nq_onStatement(core->this, nq_onVarDeclEnd(core->this));  }
          (WS ',' WS)?
        )*
        '|' WS { nq_onFunctionArgsEnd(core->this); }
        (s:Stmt { nq_onStatement(core->this, s); })*
        { tokenPos; $$=nq_onFunctionEnd(core->this); }
)


VariableAccess = i:IDENT_CORE

Value   = ('-' - '(' { tokenPos; } WS inner:Expr WS ')' { $$=nq_onUnaryMinus(core->this, nq_onParenthesis(core->this, inner)); } -)
        | ('-' - { tokenPos; } value:ValueCore { $$=nq_onUnaryMinus(core->this, value); })
        | ('(' { tokenPos; } WS inner:Expr WS ')' { $$=nq_onParenthesis(core->this, inner); } ('&' ![&=] { $$=nq_onAddressOf(core->this, $$); })? -)
        | ValueCore

ArrayLiteral = '[' { tokenPos; } WS { nq_onArrayLiteralStart(core->this); } (
                            e:Expr { nq_onStatement(core->this, e); }
               ((WS ',' | EOL) WS e:Expr { nq_onStatement(core->this, e); })*
               (WS ',' WS)?
               )? WS CLOS_SQUAR ~{ nq_error(core->this, NQE_EXP_CLOSING_SQUAR, "Malformed array literal!\n", G->pos + G->offset); }
                              { $$=nq_onArrayLiteralEnd(core->this); }

Tuple        = '(' { tokenPos; } WS { nq_onTupleStart(core->this); } (
                            e:Expr { nq_onStatement(core->this, e); }
               ((WS ',' | EOL) WS e:Expr { nq_onStatement(core->this, e); })*
               )? WS CLOS_PAREN ~{ nq_error(core->this, NQE_EXP_CLOSING_SQUAR, "Malformed tuple!\n", G->pos + G->offset); }
                              { $$=nq_onTupleEnd(core->this); }

IntLiteral =
        ( o:OCT_LIT -                                      { tokenPos; $$=nq_onOctLiteral(core->this, yytext); }
        | h:HEX_LIT -                                      { tokenPos; $$=nq_onHexLiteral(core->this, yytext); }
        | d:DEC_LIT -                                      { tokenPos; $$=nq_onDecLiteral(core->this, yytext); }
        )

ValueCore =
        ( o:OCT_LIT -                                      { tokenPos; $$=nq_onOctLiteral(core->this, yytext); }
        | h:HEX_LIT -                                      { tokenPos; $$=nq_onHexLiteral(core->this, yytext); }
        | b:BIN_LIT -                                      { tokenPos; $$=nq_onBinLiteral(core->this, yytext); }
        | f:FLOAT_LIT -                                    { tokenPos; $$=nq_onFloatLiteral(core->this, yytext); }
        | d:DEC_LIT -                                      { tokenPos; $$=nq_onDecLiteral(core->this, yytext); }
        | s:STRING_LIT -
        | c:CHAR_LIT -
        | b:BOOL_LIT  -                                    { tokenPos; $$=nq_onBoolLiteral(core->this, $$); }
        | m:Match                                          { $$=m; }
        | NULL_KW &[^A-Za-z_] -                            { tokenPos; $$=nq_onNull(core->this); }
        | ArrayLiteral
        | Tuple
        | FunctionCall
        | t:GenericType                                    { $$=nq_onTypeAccess(core->this, t); }
        | v:VariableAccess                                 { tokenPos; $$=nq_onVarAccess(core->this, NULL, v); }
        )

BREAK_KW     = "break"
CONTINUE_KW  = "continue"
RETURN_KW    = "Γύρνα"
END_KW       = "Τέλος"

FUNC_KW      = "Συνάρτηση"
CLASS_KW     = "class"
COVER_KW     = "cover"
ENUM_KW      = "enum"
INTERFACE_KW = "interface"
FROM_KW      = "from"
ABSTRACT_KW  = "abstract"
FINAL_KW     = "final"
STATIC_KW    = "static"
INLINE_KW    = "inline"
EXTENDS_KW   = "extends"
EXTERN_KW    = "εξωτερική"
UNMANGLED_KW = "unmangled"
IMPLEMENTS_KW= "implements"

IMPORT_KW    = "Εισήγαγε"
USE_KW       = "Χρήση"
IF_KW        = "Αν"
THEN_KW      = "τότε"
ELSE_KW      = "Αλλιώς"
FOR_KW       = "Για"
WHILE_KW     = "Όσο"
MATCH_KW     = "match"
CASE_KW      = "case"
AS_KW        = "as"
IN_KW        = "in"
INTO_KW      = "into"
PROTO_KW     = "proto"
TRY_KW       = "try"
CATCH_KW     = "catch"

SET_KW       = "set"
GET_KW       = "get"

OPERATOR_KW  = "operator"
CONST_KW     = "const"

TRUE_KW      = "true"
FALSE_KW     = "false"

NULL_KW      = "null"

             # a few keywords voluntarily left out
KW           = BREAK_KW | CONTINUE_KW | RETURN_KW | FUNC_KW
             | COVER_KW | ENUM_KW | FROM_KW | ABSTRACT_KW | FINAL_KW
             | STATIC_KW | INLINE_KW | EXTENDS_KW | EXTERN_KW | UNMANGLED_KW
             | IMPORT_KW | INCLUDE_KW | IF_KW | ELSE_KW | FOR_KW
             | WHILE_KW | AS_KW | OPERATOR_KW | CONST_KW | NULL_KW | MATCH_KW | CASE_KW
             | TRY_KW | CATCH_KW | END_KW | THEN_KW

DOT          = !DOUBLE_DOT '.'
COLON        = !ASS_DECL ':'

L_ARROW      = '<-'
R_ARROW      = '->'
DOUBLE_ARROW = '=>'

# Operators

ASS          = '<-' -
ASS_B_RSHIFT = '>>='  -
ASS_B_LSHIFT = '<<='  -
ASS_B_XOR    = '^='  -
ASS_B_OR     = '|='  -
ASS_B_AND    = '&='  -

QUEST        = '?'   -

L_OR         = 'ή'  -

L_AND        = 'και'  -

B_OR         = !L_OR '|' !'='   -

B_XOR        = '^' !'='   -

B_AND        = !L_AND '&' !'='  -

EQUALS       = '='  -
NOT_EQUALS   = '<>'  -

LESSTHAN     = '<'  !'=' -
MORETHAN     = '>'  !'=' -
CMP          = '<=>' -
LESSTHAN_EQ  = '<='  -
MORETHAN_EQ  = '>='  -

B_LSHIFT     = '<<' !'=' -
B_RSHIFT     = '>>' !'=' -

DOUBLE_DOT   = '..'  -

L_NOT        = '!' !'='  -
B_NOT        = '~' !'='  -
PLUS         = '+' !'='   -
MINUS        = '-' !'='  -

PERCENT = '%' !'=' -
EXP = '**' ! '=' -
STAR = '*' !'=' -
SLASH = '/' !'=' ![/*] -

CLOS_BRACK    = '}'
CLOS_SQUAR    = ']'
CLOS_PAREN    = ')'
CLOS_COMMENT  = '*/'

-          = ([ \t] | CommentMultiLine)*
EOL        = ('\n' | '\r\n' | '\r')  { core->yylineno++; }
Terminator = (CommentLine
           | CommentMultiLine? (EOL | ';')
             )
WS         = ([ \t] | Comment | EOL)*

OocDoc = "/**" < (!"*/" (EOL | .))* > "*/" { $$=nq_StringClone(yytext) } WS
       | "///" < (!EOL .)*          > EOL  { $$=nq_StringClone(yytext) } WS
       | { $$="" }
Comment = (CommentLine | CommentMultiLine)
CommentLine = "//" !'/' (!EOL .)* EOL
CommentMultiLine =    "/*" !'*' (!"*/" (EOL | CommentMultiLineWithDocs | .))* CLOS_COMMENT ~{ nq_error(core->this, NQE_UNCLOSED_COMMENT, "Unclosed multi-line comment!\n", G->pos + G->offset); }
CommentMultiLineWithDocs = "/*" (!"*/" (EOL | CommentMultiLineWithDocs | .))* CLOS_COMMENT ~{ nq_error(core->this, NQE_UNCLOSED_COMMENT, "Unclosed multi-line comment!\n", G->pos + G->offset); }

OCT_LIT      = < "0c" [0-8] [0-8_]* >
BIN_LIT      = < "0b" [01] [01_]* >
HEX_LIT      = < "0x" [0-9a-fA-F] [0-9a-fA-F_]* >
FLOAT_LIT    = < "-"? [0-9_]+ DOT [0-9_]* >        -
DEC_LIT      = < "-"? [0-9] [0-9_]* >                   -

IDENT        = i:IDENT_CORE -
IDENT_CORE   = !(KW ![A-Za-z0-9_])  # a keyword is not an ident
               < [a-zA-Z_][0-9a-zA-Z_]* > { $$=yytext; }
               ( '?' { $$=nq_trailingQuest($$); }
               | '!' { $$=nq_trailingBang($$); })?
               
SINGLE_QUOTE = '\''
DOUBLE_QUOTE = '"'

STRING_LIT   = '"' < (!'"'   ("\\" ('x'[0-9A-Za-z][0-9A-Za-z]([0-9A-Za-z][0-9A-Za-z])? | [0-9][0-9]?[0-9]? | ["'abtnvfr0\\]) | EOL | .))* >
               DOUBLE_QUOTE ~{ nq_error(core->this, NQE_MALFORMED_STRINGLIT , "Malformed string literal!\n", G->pos + G->offset); }
               -  { tokenPos; $$=nq_onStringLiteral(core->this, yytext); }
CHAR_LIT     = '\'' < (!'\'' ("\\" ('x'[0-9A-Za-z][0-9A-Za-z]([0-9A-Za-z][0-9A-Za-z])? | [0-9][0-9]?[0-9]? | ["'abtnvfr0\\]) | .)) >
               SINGLE_QUOTE  ~{ nq_error(core->this, NQE_MALFORMED_CHARLIT , "Malformed char literal!\n", G->pos + G->offset); }
               -  { tokenPos; $$=nq_onCharLiteral(core->this, yytext); }
BOOL_LIT     = (TRUE_KW &[^A-Za-z_] { $$=(void*) true; } | FALSE_KW &[^A-Za-z_] { $$=(void*) false; }) -

%%

int nq_parse(void *this, char *path) {

    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    G->buflen = 0;

    NagaQueenCore *core = YY_ALLOC(sizeof(NagaQueenCore), 0);
    core->yylineno = 0;
    core->this = this;
    core->path = path;
    core->stream = fopen(path, "r");
    nq_setTokenPositionPointer(this, core->token);
    if(!core->stream) {
        printf("Not found: %s\n", path);
        return -1;
    }

    G->data = core;

    while (yyparse(G)) {}
    fclose(core->stream);

    return 0;

}

